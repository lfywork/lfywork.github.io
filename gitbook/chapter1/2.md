# Environment Setting
2017年12月22日 星期五：
1、静态链接
之所以称之为"静态库"，是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。
从本质上来说，一个静态库可以简单看成是一组目标文件(.o/.obj文件)的集合，静态库与汇编生成的目标文件(.o/.obj)一起链接为可执行文件。
静态库（后缀为.a/.lib）和.o文件格式相似。即很多目标文件经过压缩打包后形成的一个文件
静态库特点总结：
1. 静态库对函数库的链接是放在编译时期完成的
2. 程序在运行时与函数库再无瓜葛，移植方便，因为代码已经嵌入到程序里面了，可以直接跟着程序走，不存在对外部文件的依赖
3. 浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件，会增加原本程序的空间
GCC编译、使用静态库
静态库的后缀是.a(并没有强制规定)，它的产生分两步
1. 由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表
2. ar命令将很多.o转换成.a，成为静态库，从这点也可以看出来，库是很多.o文件的集合
编译好静态库文件之后，我们就可以在其他程序中使用静态库文件中的函数了
1. 只需要在使用到这些公用函数的源程序中包含这些公用函数的原型声明(include对应的头文件)
2. 然后在用gcc命令生成目标文件时指明静态库名
3. gcc将会从静态库中将公用函数连接到目标文件中
4. 注意，gcc会在静态库名前加上前缀lib，然后追加扩展名.a得到的静态库文件名来查找静态库文件,因此，我们在写需要连接的库时，只写名字就可以，如libhello.a的库，只写: -lhello
2、动态链接
动态库文件名命名规范和静态库文件名命名规范类似，也是在动态库名增加前缀lib，但其文件扩展名为.so（.dll）。例如：我们将创建的动态库名为myhello，则动态库文件名就是libmyhello.so。
使用库是重用代码的一种绝佳方式。 您不必在自己创建的每个程序中重新实现同一例程，而只需对这些例程写入一次，然后从需要该功能的应用程序引用它们即可。 通过将代码放入 DLL，您节省在引用它的每个应用程序的空间，而且，您可以更新 DLL，而无需重新编译所有应用程序。
动态链接库 (DLL) 是作为共享函数库的可执行文件。动态链接提供了一种方法，使进程可以调用不属于其可执行代码的函数。DLL 还有助于共享数据和资源。多个应用程序可同时访问内存中单个 DLL 副本的内容。
动态链接与静态链接的不同之处在于它允许可执行模块（.dll 文件或 .exe 文件）仅包含在运行时定位 DLL 函数的可执行代码所需的信息。在静态链接中，链接器从静态链接库获取所有被引用的函数，并将库同代码一起放到可执行文件中。
使用动态链接代替静态链接有若干优点。DLL 节省内存，减少交换操作，节省磁盘空间，更易于升级，提供售后支持，提供扩展 MFC 库类的机制，支持多语言程序，并使国际版本的创建轻松完成。
DLL 的类型
当您在应用程序中加载 DLL 时，可以使用两种链接方法来调用导出的 DLL 函数。这两种链接方法是加载时动态链接和运行时动态链接。
动态库一般会有对应的导入库，方便程序静态载入动态链接库，否则你可能就需要自己LoadLibary调入DLL文件，然后再手工GetProcAddress获得对应函数了。有了导入库，你只需要链接导入库后按照头文件函数接口的声明调用函数就可以了。
加载时动态链接（load-time dynamic linking）
在加载时动态链接中，应用程序像调用本地函数一样对导出的 DLL 函数进行显式调用。要使用加载时动态链接，请在编译和链接应用程序时提供头文件 (.h) 和导入库文件 (.lib)。当您这样做时，链接器将向系统提供加载 DLL 所需的信息，并在加载时解析导出的 DLL 函数的位置。
运行时动态链接（run-time dynamic linking）
在运行时动态链接中，应用程序调用 LoadLibrary 函数或 LoadLibraryEx 函数以在运行时加载 DLL。成功加载 DLL 后，可以使用 GetProcAddress 函数获得要调用的导出的 DLL 函数的地址。在使用运行时动态链接时，无需使用导入库文件。
所谓静态、动态是指"链接"的过程存在区别:

3、Linux下C语言程序的 编译过程
./a.out: a.out 是linux/unix环境下gcc编译源代码(c/c++)并连接产生的默认执行文件名。./a.out表示当前目录下的a.out文件。一个单独的点号指代当前文件路径。因为linux/unix搜索可执行文件的默认路径需要指定，没有./两个符号指定路径的话，新编译的文件操作系统找不到。
第一阶段
在预处理阶段，输入的是C语言源文件，通常为*.c或者*.C，它们一般带有*h之类的头文件。这个阶段主要处理源文件中的#ifdef、#include和#define预处理命令。该阶段会生成一个中间文件*.i
1.生成预处理后的文件hello.i
$ gcc -E hello.c -o hello.i
它通过对源文件hello.c使用E选项来生成中间文件hello.i
第二阶段
在编译阶段，输入的是中间文件*.i，编译后生成汇编语言文件*.s。这个阶段对应的gcc命令如下所示：
2.生成汇编语言文件hello.s
$ gcc-s hello.i -o hello.s
第三阶段
在汇编阶段，将输入的汇编文件*.s转换成二进制机器代码*.o，这个阶段对应的gcc命令如下所示：
$ gcc -c hello.s-o hello.o
第四阶段
在链接阶段，将输入的二进制机器代码文件*.o（与其他机器代码文件和库文件)汇集成一个可执行的二进制代码文件。
4.生成可执行文件
$ gcc hello.o -o hello
总结版：
对应以上四个阶段，直接一个命令
gcc hello.c -o hello
最后阶段
5.运行及结果
$ ./hello
Hello world!
5、ATTENTION
2017年12月24日 星期日
include 头文件的路径对源文件的编译运行是否会有影响？(涉及编译原理)
ldd 程序：显示程序需要动态链接库的信息